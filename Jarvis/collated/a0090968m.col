//@author: a0090968m



	/**
	 * origin: C:\Users\Gabriel\Documents\GitHub\main\Jarvis\Jarvis\parser.cpp
	 */

Task CommandParser::parseString(string userInput, RecurringTask &R1) {
	
	string desc;
	string date;
	string month;
	string hour;
	string minute;
	string StartHour;
	string StartMinute;
	string EndHour;
	string EndMinute;
	int intHour;
	int intMin;
	int intSHour;
	int intEHour;
	int intSMin;
	int intEMin;
	string str = "on";
	ptime now = microsec_clock::local_time();
	time_duration tod = now.time_of_day();
	int gregDate,gregMonth,gregYear=2015;
	bool deadline,floating,timedBy,timedFrom,recurring=false;
	boost::trim(userInput);
	vector <string> tokens;
	vector <string> tokensBeforeTrim;
	vector <string> originalTokens;
	Task T1;
	int i;

	boost::split(tokensBeforeTrim,userInput,boost::is_any_of(" "));                 //split by occurences of " "
	for(i=0;i<tokensBeforeTrim.size();i++) {
		if(tokensBeforeTrim[i].find_first_not_of(' ') != string::npos) {
			originalTokens.push_back(tokensBeforeTrim[i]);
			tokens.push_back(changeToLowerCase(tokensBeforeTrim[i]));
		}
	}
	
	if(userInput==""){
		T1.setBlankString(true);
		return T1;
	}

	//Search for "on" keyword
	for(i=0;i<tokens.size();i++) {

		if(tokens[i]=="on") {
			findYear(tokens,i,T1);
			if(T1.getErrorDate())
				return T1;
			if((i+2)<=tokens.size()) {
				if(isYearValid){
					deadline=true;
					break;
				}                        //only date task on 21 march
				try {
					gregDate = stoi(tokens[i+1]);
				}
				catch (const std::invalid_argument) {                  //catches if not deadline task
					deadline = false;
					continue;
				}
	
				gregMonth = getMonthNumber(tokens[i+2]);                            //2 tokens after on, is month
				
				try {                                                            //check if date and numebrs are correct, gregorian converts into numbers
					boost::gregorian::date d(gregYear, gregMonth, gregDate);
					ptime now = microsec_clock::local_time();
					boost::gregorian::date today = now.date();

					if(d<today) {
						T1.setErrorDate(true);
						deadline=false;
					}
					else {
						deadline=true;
						break;
					}
					}
				catch (std::out_of_range) {
					bool value=true;
					T1.setErrorDate(value);
					deadline=false;
				}
			}
	}

	}
	if(i==tokens.size()) {                    //if on keyword doesnt exist, then not a deadline task
		deadline=false;                      //end of scanning through tokens, if on keyword doesnt exist, then not a deadline task
	}
	if(deadline) {
		for(int j=0;j<i;j++) {
			desc = desc + originalTokens[j] + " ";                   //description = add buy veggies on 21 march
		}
		T1.setDescription(desc);
		T1.setDate(tokens[i+1]);
		T1.setMonth(tokens[i+2]);
		gregDate = stoi(T1.getDate());
		gregMonth = getMonthNumber(T1.getMonth());
		gregYear = stoi(T1.getYear());
		boost::gregorian::date d(gregYear, gregMonth, gregDate);
		if((i+3)==tokens.size())
			return T1;                                             //no timed tasks, only date month year

		else if((i+5)==tokens.size()) {//by timed task                 //TASK : on 21[i+1] march[i+2] by[i+3] 13:00[i+4]
			if(tokens[i+3]=="by") {
				vector <string> byTime;
				boost::split(byTime,tokens[i+4],boost::is_any_of(":"));            //"13 00" stored in byTime vector
				if(isHourValid(byTime[0]) && isMinuteValid(byTime[1]) && byTime.size()==2) {
					string userTime = byTime[0]+":"+byTime[1]+":00";
					time_duration td(duration_from_string(userTime));
					intHour = stoi(byTime[0]);
					intMin = stoi(byTime[1]);
					if(isTimeValid(td,d)) {
					if(intHour<9){
						T1.setHour('0'+to_string(intHour));
					} else {
						T1.setHour(to_string(intHour));
					}
					if(intMin<9){
						T1.setMinute('0'+to_string(intMin));
					} else {
						T1.setMinute(to_string(intMin));
					}
				}
					else  {
						T1.setTimeError(true);
					}
				}
				else {
					bool value=true;
					T1.setTimeError(value);
				}


			}
			else {
				bool value=true;
				T1.setCommandError(value);
			}
	
		}

		else if((i+7)==tokens.size()) { // from to timed task
			if(tokens[i+3]=="from" && tokens[i+5]=="to") {                //on 21[i+1] march[i+2] from[i+3] 12:00[i+4] to[i+4] 13:00[i+5]
				vector <string> fromTime;
				boost::split(fromTime,tokens[i+4],boost::is_any_of(":"));
				
				vector <string> toTime;
				boost::split(toTime,tokens[i+6],boost::is_any_of(":"));
				if(isHourValid(toTime[0]) && isHourValid(fromTime[0]) && isMinuteValid(toTime[1]) && isMinuteValid(fromTime[1]) && fromTime.size()==2 && toTime.size()==2) {
					string userStartTime = fromTime[0]+":"+fromTime[1]+":00";
					time_duration tdStart(duration_from_string(userStartTime));
					string userEndTime = toTime[0]+":"+toTime[1]+":00";
					time_duration tdEnd(duration_from_string(userEndTime));
					intSHour = stoi(fromTime[0]);
					intSMin = stoi(fromTime[1]);
					intEHour = stoi(toTime[0]);
					intEMin = stoi(toTime[1]);
					if(toTime[0]<fromTime[0]) {
						T1.setTimeError(true);
						return T1;
					}
					if((toTime[0]==fromTime[0])&&(toTime[1]<=fromTime[1])){
						T1.setTimeError(true);
						return T1;
					}
					if(isTimeValid(tdStart,d)&&isTimeValid(tdEnd,d)) {
					if(intSHour<9){
						T1.setStartHour('0'+to_string(intSHour));
					} else {
						T1.setStartHour(to_string(intSHour));
					}
					if(intSMin<9){
						T1.setStartMinute('0'+to_string(intSMin));
					} else {
						T1.setStartMinute(to_string(intSMin));
					}
					if(intEHour<9){
						T1.setEndHour('0'+to_string(intEHour));
					} else {
						T1.setEndHour(to_string(intEHour));
					}
					if(intEMin<9){
						T1.setEndMinute('0'+to_string(intEMin));
					} else {
						T1.setEndMinute(to_string(intEMin));
					}
				}

					else
						T1.setTimeError(true);

				}

				else {
					bool value=true;
					T1.setTimeError(value);
				}


			}

			else {
				bool value=true;
				T1.setCommandError(value);
			}

			 //function ends
		}
		else {                          //error in format of input 
			bool value=true;
			T1.setCommandError(value);
			return T1;
		}
	
	
	
	
	}               //closing deadline tasks

	else if(!deadline && !T1.getErrorDate()) {
		int a;
		for(a=0;a<tokens.size();a++) {                        //recurring task add buy apples every friday by
			 if(tokens[a]=="every") { 
				 R1.setRecWord(tokens[a]);
				 if((a+3)<=tokens.size() && isDayValid(tokens[a+1])) {	 //CHANGED
					if(tokens[a+2]=="until"){
						 findYear(tokens,(a+2),T1);
						 if(T1.getErrorDate()) {
							 return T1;
						 }
						if((a+5)==tokens.size()) {	
							R1.setWord(tokens[a+2]);
							if(isYearValid) {
								for(int b=0;b<a;b++) {
									desc = desc + originalTokens[b] + " ";
								}
								T1.setDescription(desc);
								R1.setTaskDay(tokens[a+1]);
								R1.setEndDate(tokens[a+3]);
								R1.setEndMonth(tokens[a+4]);
								R1.setRecurring(true);
								break;
							}

						 
						try {
							gregDate = stoi(tokens[a+3]);
						}
						catch (const std::invalid_argument) {
							recurring = false;
							break;
						}
	
						gregMonth = getMonthNumber(tokens[a+4]);
				
						try {
							boost::gregorian::date d(gregYear, gregMonth, gregDate);
							ptime now = microsec_clock::local_time();
							boost::gregorian::date today = now.date();
							if(d<today) {
								R1.setRecurringError(true);
								R1.setRecurring(false);
							}
							else {
								recurring=true;
								R1.setRecurring(recurring);
							}
							for(int b=0;b<a;b++) {
								desc = desc + originalTokens[b] + " ";
							}
							T1.setDescription(desc);
							R1.setTaskDay(tokens[a+1]);
							R1.setEndDate(tokens[a+3]);
							R1.setEndMonth(tokens[a+4]);
							break;
						}
						catch (std::out_of_range) {
							bool value=true;
							T1.setErrorDate(value);
							recurring=false;
						}

					}
					 }
						 
					 else if((a+3)==tokens.size() && ((tokens[a+2]).at(0)=='x' || (tokens[a+2]).at(0)=='X') && isdigit(tokens[a+2].at(1))) {
							 R1.setWord(tokens[a+2]);
							 for(int b=0;b<a;b++) {
								 desc = desc + originalTokens[b] + " ";
							}
							 T1.setDescription(desc);
							 R1.setTaskDay(tokens[a+1]);
							 R1.setRecurring(true);
							 break;
						}
						
					 else if((a+7)==tokens.size() && tokens[a+4]=="until" && tokens[a+2]=="by" ) {
						 findYear(tokens,(a+4),T1);
						 if(T1.getErrorDate()) {
							 return T1;	
						 }
						 vector <string> byRecTime;
							boost::split(byRecTime,tokens[a+3],boost::is_any_of(":"));
							if(byRecTime.size()==2 && isHourValid(byRecTime[0]) && isMinuteValid(byRecTime[1])) {
								intHour = stoi(byRecTime[0]);
								intMin = stoi(byRecTime[1]);
									if(intHour<9){
										T1.setHour('0'+to_string(intHour));
									} else {
										T1.setHour(to_string(intHour));
									}
									if(intMin<9){
										T1.setMinute('0'+to_string(intMin));
									} else {
										T1.setMinute(to_string(intMin));
								}
							
							
						}
							else 
								T1.setTimeError(true);

						 if((a+7)==tokens.size()) {
							R1.setWord(tokens[a+4]); 
							if(isYearValid) {
								R1.setRecurring(true);
								for(int b=0;b<a;b++) {
								desc = desc + originalTokens[b] + " ";
							}
							T1.setDescription(desc);
							R1.setTaskDay(tokens[a+1]);
							R1.setEndDate(tokens[a+5]);
							R1.setEndMonth(tokens[a+6]);
								break;
							}
							
							 
						try {
							gregDate = stoi(tokens[a+5]);
						}
						catch (const std::invalid_argument) {
							R1.setRecurringError(true);
							break;
						}
	
						gregMonth = getMonthNumber(tokens[a+6]);
				
						try {
							boost::gregorian::date d(gregYear, gregMonth, gregDate);
							ptime now = microsec_clock::local_time();
							boost::gregorian::date today = now.date();
							if(d<today) {
								dateValid=false;
								R1.setRecurringError(true);
								R1.setRecurring(false);
							}
							else {
								
								dateValid=true;
								recurring=true;
								R1.setRecurring(recurring);
							}
							for(int b=0;b<a;b++) {
								desc = desc + originalTokens[b] + " ";
							}
							T1.setDescription(desc);
							R1.setTaskDay(tokens[a+1]);
							R1.setEndDate(tokens[a+5]);
							R1.setEndMonth(tokens[a+6]);
							break;
						}
						catch (std::out_of_range) {
							bool value=true;
							T1.setErrorDate(value);
							recurring=false;
						}

						
					 }
						
						

						else {
							bool value=true;
							T1.setErrorDate(value);
							return T1;
						} 
						
						
					 }
					 else if((a+5)==tokens.size() && ((tokens[a+4]).at(0)=='x' || (tokens[a+4]).at(0)=='X')  && isdigit(tokens[a+4].at(1))) {
							vector <string> byRecTime;
						boost::split(byRecTime,tokens[a+3],boost::is_any_of(":"));
						if(byRecTime.size()==2 && isHourValid(byRecTime[0]) && isMinuteValid(byRecTime[1])) {
								intHour = stoi(byRecTime[0]);
								intMin = stoi(byRecTime[1]);
									if(intHour<9){
										T1.setHour('0'+to_string(intHour));
									} else {
										T1.setHour(to_string(intHour));
									}
									if(intMin<9){
										T1.setMinute('0'+to_string(intMin));
									} else {
										T1.setMinute(to_string(intMin));
								}
						}

						else {
							bool value=true;
							T1.setTimeError(value);
							return T1;
						}
							R1.setWord(tokens[a+4]);
							for(int b=0;b<a;b++) {
								desc = desc + originalTokens[b] + " ";
							}
							T1.setDescription(desc);
							R1.setTaskDay(tokens[a+1]);
							R1.setRecurring(true);
							 break;
						}
					 else if((a+7)<=tokens.size() && tokens[a+6]=="until" && tokens[a+2]=="from" && tokens[a+4]=="to") {
						 findYear(tokens,(a+6),T1);
						 if(T1.getErrorDate())
							 return T1;
						 vector <string> fromRecTime;
				
						boost::split(fromRecTime,tokens[a+3],boost::is_any_of(":"));
				
				vector <string> toRecTime;
				boost::split(toRecTime,tokens[a+5],boost::is_any_of(":"));
				if(fromRecTime.size()==2 && toRecTime.size()==2 && isHourValid(toRecTime[0]) && isHourValid(fromRecTime[0]) && isMinuteValid(toRecTime[1]) && isMinuteValid(fromRecTime[1])) {
					if(toRecTime[0]<fromRecTime[0]) {
						T1.setTimeError(true);
						return T1;
					}
					if((toRecTime[0]==fromRecTime[0])&&(toRecTime[1]<=fromRecTime[1])){
						T1.setTimeError(true);
						return T1;
					}
					intSHour = stoi(fromRecTime[0]);
					intSMin = stoi(fromRecTime[1]);
					intEHour = stoi(toRecTime[0]);
					intEMin = stoi(toRecTime[1]);
					if(intSHour<9){
						T1.setStartHour('0'+to_string(intSHour));
					} else {
						T1.setStartHour(to_string(intSHour));
					}
					if(intSMin<9){
						T1.setStartMinute('0'+to_string(intSMin));
					} else {
						T1.setStartMinute(to_string(intSMin));
					}
					if(intEHour<9){
						T1.setEndHour('0'+to_string(intEHour));
					} else {
						T1.setEndHour(to_string(intEHour));
					}
					if(intEMin<9){
						T1.setEndMinute('0'+to_string(intEMin));
					} else {
						T1.setEndMinute(to_string(intEMin));
					}
					
				}
						else {
							bool value=true;
							T1.setTimeError(value);
							return T1;
						} 
						if((a+9)==tokens.size()) {
							R1.setWord(tokens[a+6]);
							if(isYearValid) {
								for(int b=0;b<a;b++) {
								desc = desc + originalTokens[b] + " ";
							}
							T1.setDescription(desc);
							R1.setTaskDay(tokens[a+1]);
							R1.setEndDate(tokens[a+7]);
							R1.setEndMonth(tokens[a+8]);
								R1.setRecurring(true);
								break;
							}

						try {
							gregDate = stoi(tokens[a+7]);
						}
						catch (const std::invalid_argument) {
							R1.setRecurringError(true);
							break;
						}
	
						gregMonth = getMonthNumber(tokens[a+8]);
				
						try {
							boost::gregorian::date d(gregYear, gregMonth, gregDate);
							ptime now = microsec_clock::local_time();
							boost::gregorian::date today = now.date();
							if(d<today) {
								R1.setRecurringError(true);
								R1.setRecurring(false);
							}
							else {
								recurring=true;
								R1.setRecurring(recurring);
							}
							for(int b=0;b<a;b++) {
								desc = desc + originalTokens[b] + " ";
							}
							T1.setDescription(desc);
							R1.setTaskDay(tokens[a+1]);
							R1.setEndDate(tokens[a+7]);
							R1.setEndMonth(tokens[a+8]);
							break;
						}
						catch (std::out_of_range) {
							bool value=true;
							T1.setErrorDate(value);
							recurring=false;
						}
					
						
	
					 }
					 }
					 
					 else if((a+7)==tokens.size() &&((tokens[a+6]).at(0)=='x' || (tokens[a+6]).at(0)=='X') && isdigit(tokens[a+6].at(1))) {
								vector <string> fromRecTime;
							boost::split(fromRecTime,tokens[a+3],boost::is_any_of(":"));
				
				vector <string> toRecTime;
				boost::split(toRecTime,tokens[a+5],boost::is_any_of(":"));
				if(fromRecTime.size()==2 && toRecTime.size()==2 && isHourValid(toRecTime[0]) && isHourValid(fromRecTime[0]) && isMinuteValid(toRecTime[1]) && isMinuteValid(fromRecTime[1])) {
					
					if(toRecTime[0]<fromRecTime[0]) {
						T1.setTimeError(true);
						return T1;
					}
					if((toRecTime[0]==fromRecTime[0])&&(toRecTime[1]<=fromRecTime[1])){
						T1.setTimeError(true);
						return T1;
					}
					intSHour = stoi(fromRecTime[0]);
					intSMin = stoi(fromRecTime[1]);
					intEHour = stoi(toRecTime[0]);
					intEMin = stoi(toRecTime[1]);
					if(intSHour<9){
						T1.setStartHour('0'+to_string(intSHour));
					} else {
						T1.setStartHour(to_string(intSHour));
					}
					if(intSMin<9){
						T1.setStartMinute('0'+to_string(intSMin));
					} else {
						T1.setStartMinute(to_string(intSMin));
					}
					if(intEHour<9){
						T1.setEndHour('0'+to_string(intEHour));
					} else {
						T1.setEndHour(to_string(intEHour));
					}
					if(intEMin<9){
						T1.setStartMinute('0'+to_string(intEMin));
					} else {
						T1.setStartMinute(to_string(intEMin));
					}
				}
						else {
							bool value=true;
							T1.setTimeError(value);
							return T1;
						}	 
						 R1.setWord(tokens[a+6]);
							 for(int b=0;b<a;b++) {
								 desc = desc + originalTokens[b] + " ";
							}
							T1.setDescription(desc);
							R1.setTaskDay(tokens[a+1]);
							 R1.setRecurring(true);
							 break;
					}
					 else {
						 bool value=true;
						 R1.setRecurringError(value);

					}
				 }

			}
			else if(tokens[a]=="from") { // add ..... from 23 march 2015 daily.....
				R1.setRecWord(tokens[a]);
				findRecDate(tokens,a,R1);
				if(isWrongDate){
					T1.setErrorDate(true);
				}
				if(!R1.getRecurring() && T1.getErrorDate()) {
					return T1;

				}
				else if(R1.getRecurring()) {
					if((a+3)<=tokens.size() && isPeriodValid(tokens[a+3])) {
						R1.setPeriod(tokens[a+3]);
						if(tokens[a+4]=="until"){

							findYear(tokens,(a+4),T1);
							if(isWrongDate){
								R1.setRecurring(false);
								T1.setErrorDate(true);
							}
							if(T1.getErrorDate()) {
								return T1;
							}
							if((a+7)==tokens.size()) {	
								R1.setWord(tokens[a+4]);
								if(isYearValid) {
									for(int b=0;b<a;b++) {
										desc = desc + originalTokens[b] + " ";
									}
								T1.setDescription(desc);
								R1.setEndDate(tokens[a+5]);
								R1.setEndMonth(tokens[a+6]);
								R1.setRecurring(true);
								break;
							}

						 
						try {
							gregDate = stoi(tokens[a+5]);
						}
						catch (const std::invalid_argument) {
							R1.setRecurring(false);
							break;
						}
	
						gregMonth = getMonthNumber(tokens[a+6]);

						try {
							boost::gregorian::date d(gregYear, gregMonth, gregDate);
							ptime now = microsec_clock::local_time();
							boost::gregorian::date today = now.date();
							if(d<today) {
								R1.setRecurringError(true);
								R1.setRecurring(false);
							}
							else {
								recurring=true;
								R1.setRecurring(recurring);
							}
							for(int b=0;b<a;b++) {
								desc = desc + originalTokens[b] + " ";
							}

							T1.setDescription(desc);
							R1.setEndDate(tokens[a+5]);
							R1.setEndMonth(tokens[a+6]);
							break;
						}
						catch (std::out_of_range) {
							bool value=true;
							
							T1.setErrorDate(value);
							R1.setRecurring(false);
						}

					}
							else {
								R1.setRecurringError(true);
								R1.setRecurring(false);
							}
							}
		
					 else if((a+5)==tokens.size() &&((tokens[a+4]).at(0)=='x' || (tokens[a+4]).at(0)=='X') && isdigit(tokens[a+4].at(1))) {
							R1.setWord(tokens[a+4]);
							 for(int b=0;b<a;b++) {
								 desc = desc + originalTokens[b] + " ";
							}
							T1.setDescription(desc);
							R1.setRecurring(true);
							return T1;
						}
						

					}
					else {
						
						R1.setRecurringError(true);
						return T1;
					}


				}
			
			}

		}
		if(a==tokens.size()) {
			bool value=false;
			R1.setRecurring(false);
		}
	}
	if(!deadline && !R1.getRecurring()) {
		for(int j=0;j<originalTokens.size();j++) {
			desc = desc + originalTokens[j] + " ";
		}
		T1.setDescription(desc);
	}

	if(T1.getErrorDate()) {
		return T1;
	}


return T1;
}

Task CommandParser::parserUpdate(string userInput){
	vector <string> tokensToUpdate;
	vector <string> tokensBeforeTrim;
	boost::split(tokensBeforeTrim,userInput,boost::is_any_of(" "));
	for(int i=0;i<tokensBeforeTrim.size();i++) {
		if(tokensBeforeTrim[i].find_first_not_of(' ') != string::npos) {
			tokensToUpdate.push_back(changeToLowerCase(tokensBeforeTrim[i]));
		}
	}
	Task T1;
	T1.setUpdateTokens(tokensToUpdate);
	return T1;
}

	// End of segment: C:\Users\Gabriel\Documents\GitHub\main\Jarvis\Jarvis\parser.cpp





